#ifndef PATHTRACERSCENE_H
#define PATHTRACERSCENE_H

/// @class PathTracerScene
/// @date 06/01/15
/// @author Declan Russell
/// @brief A class to manage our OptiX path tracer.
/// @brief This is a singleton class for easy access in other areas of the program


#include "renderer/AbstractOptixRenderer.h"


#include <QImage>

#include <glm/glm.hpp>
#include "common/random.h"
#include "lights/ParallelogramLight.h"
#include "common/helpers.h"
#include "renderer/PathTraceCamera.h"
#include "geometry/Mesh.h"


class PathTracerScene : public AbstractOptixRenderer
{
protected:
    typedef optix::float3 float3;
    typedef optix::float4 float4;
    typedef optix::Material Material;
    typedef optix::Transform Transform;
    typedef optix::Geometry Geometry;
    typedef optix::GeometryInstance GeometryInstance;
    typedef optix::Group Group;

public:
    //----------------------------------------------------------------------------------------------------------------------
    /// @brief our default constructor
    //----------------------------------------------------------------------------------------------------------------------
    PathTracerScene();
    //----------------------------------------------------------------------------------------------------------------------
    /// @brief  dtor
    //----------------------------------------------------------------------------------------------------------------------
    ~PathTracerScene();
    //----------------------------------------------------------------------------------------------------------------------
    /// @brief initialise our class
    //----------------------------------------------------------------------------------------------------------------------
    void initialize();
    //----------------------------------------------------------------------------------------------------------------------
    /// @brief our trace function that launches our Optix context
    //----------------------------------------------------------------------------------------------------------------------
    void trace();
    //----------------------------------------------------------------------------------------------------------------------
    /// @brief adds geometry to our scene
    /// @param _geo - geometry to add to scene
    //----------------------------------------------------------------------------------------------------------------------
    virtual void addGeometry(AbstractOptixGeometry *_geo);
    //----------------------------------------------------------------------------------------------------------------------
    /// @brief removes geometry from our scene
    /// @param _geo - geometry to remove from the scene
    //----------------------------------------------------------------------------------------------------------------------
    virtual void removeGeometry(AbstractOptixGeometry *_geo);
    //----------------------------------------------------------------------------------------------------------------------
    /// @brief set the square root number of samples
    //----------------------------------------------------------------------------------------------------------------------
    inline void setNumSamples( float sns ){ m_sqrt_num_samples=sns; getContext()["sqrt_num_samples"]->setUint(sns); }
    //----------------------------------------------------------------------------------------------------------------------
    /// @brief accessor to our total number of samples
    //----------------------------------------------------------------------------------------------------------------------
    inline int getNumSamples(){return m_sqrt_num_samples;}
    //----------------------------------------------------------------------------------------------------------------------
    /// @brief resize our scene
    //----------------------------------------------------------------------------------------------------------------------
    void resize(unsigned int _width,unsigned int _height);
    //----------------------------------------------------------------------------------------------------------------------
    /// @brief signals if our camera has changed
    //----------------------------------------------------------------------------------------------------------------------
    inline void signalCameraChanged(){m_cameraChanged=true;}
    //----------------------------------------------------------------------------------------------------------------------
    /// @brief rebuilds the scene
    //----------------------------------------------------------------------------------------------------------------------
    virtual void rebuildScene();
    //----------------------------------------------------------------------------------------------------------------------
    /// @brief resets the frame count if the scene has changed
    //----------------------------------------------------------------------------------------------------------------------
    inline void signalSceneChanged(){m_frame = 0;}
    //----------------------------------------------------------------------------------------------------------------------
    /// @brief updates our camera the instance of our camera
    //----------------------------------------------------------------------------------------------------------------------
    void updateCamera();
    //----------------------------------------------------------------------------------------------------------------------
    /// @brief accesor to our scenes camera
    /// @return our camera
    //----------------------------------------------------------------------------------------------------------------------
    inline PathTraceCamera* getCamera(){return m_camera;}
    //----------------------------------------------------------------------------------------------------------------------
    /// @brief Reevaluate the acceleration structure of the top model
    //----------------------------------------------------------------------------------------------------------------------
    void cleanTopAcceleration();
    //----------------------------------------------------------------------------------------------------------------------
    /// @brief sets the max ray depth in our path tracer
    //----------------------------------------------------------------------------------------------------------------------
    inline void setMaxRayDepth(int _depth){getContext()["maxDepth"]->setUint(_depth); m_maxRayDepth = _depth;}
    //----------------------------------------------------------------------------------------------------------------------
    /// @brief accesor to the max ray depth of our path tracer
    //----------------------------------------------------------------------------------------------------------------------
    inline int getMaxRayDepth(){return m_maxRayDepth;}
    //----------------------------------------------------------------------------------------------------------------------
    /// @brief mutator for our global transform
    /// @param _trans - desired global transform
    //----------------------------------------------------------------------------------------------------------------------
    virtual void setTransform(float* _trans, float* _invTrans, bool _transpose);
    //----------------------------------------------------------------------------------------------------------------------
    /// @brief Get global trans transform
    //----------------------------------------------------------------------------------------------------------------------
    inline Transform getGlobalTrans(){return m_globalTrans;}
    //----------------------------------------------------------------------------------------------------------------------
    /// @brief accesor to the total number of polygons in our scene
    //----------------------------------------------------------------------------------------------------------------------
    inline int getTotalScenePolygons(){return m_totalNumPolygons;}
    //----------------------------------------------------------------------------------------------------------------------
    /// @brief sets material of geometry instance
    //----------------------------------------------------------------------------------------------------------------------
    void setMaterial(GeometryInstance& gi,Material material,const std::string& color_name,const float3& color);
    //----------------------------------------------------------------------------------------------------------------------
    /// @brief creates a parallelogram piece of geometry
    //----------------------------------------------------------------------------------------------------------------------
    optix::GeometryInstance createParallelogram(const float3& anchor, const float3& offset1, const float3& offset2);
    //----------------------------------------------------------------------------------------------------------------------
    /// @brief function to load our simple test geometry
    //----------------------------------------------------------------------------------------------------------------------
    void loadTestGeomtry();
    //----------------------------------------------------------------------------------------------------------------------
private:
    //----------------------------------------------------------------------------------------------------------------------
    /// @brief total number of polygons in the scene
    //----------------------------------------------------------------------------------------------------------------------
    int m_totalNumPolygons;
    //----------------------------------------------------------------------------------------------------------------------
    /// @brief the max ray traversal depth of our path tracer
    //----------------------------------------------------------------------------------------------------------------------
    int m_maxRayDepth;
    //----------------------------------------------------------------------------------------------------------------------
    /// @brief the top group of our scene
    //----------------------------------------------------------------------------------------------------------------------
    Group m_topGroup;
    //----------------------------------------------------------------------------------------------------------------------
    /// @brief the global transform our our scene used for camera controls
    //----------------------------------------------------------------------------------------------------------------------
    Transform m_globalTrans;
    //----------------------------------------------------------------------------------------------------------------------
    /// @brief group with our global transform applied. Any child of this will be effected by our global transform node
    //----------------------------------------------------------------------------------------------------------------------
    Group m_globalTransGroup;
    //----------------------------------------------------------------------------------------------------------------------
    /// @brief a bool to notify us if the camera has changed and we need to update engine camera paramiters
    //----------------------------------------------------------------------------------------------------------------------
    bool m_cameraChanged;
    //----------------------------------------------------------------------------------------------------------------------
    /// @brief the camera of our scene
    //----------------------------------------------------------------------------------------------------------------------
    PathTraceCamera *m_camera;
    //----------------------------------------------------------------------------------------------------------------------
    /// @brief the depth of our ray?
    //----------------------------------------------------------------------------------------------------------------------
    unsigned int m_rr_begin_depth;
    //----------------------------------------------------------------------------------------------------------------------
    /// @brief the sqrt of the number of samples we want
    /// @brief sqrt's are expensive GPU so lets do it on the CPU
    //----------------------------------------------------------------------------------------------------------------------
    unsigned int m_sqrt_num_samples;
    //----------------------------------------------------------------------------------------------------------------------
    /// @brief current frame number
    //----------------------------------------------------------------------------------------------------------------------
    unsigned int m_frame;
    //----------------------------------------------------------------------------------------------------------------------
    /// @brief our sampling strategy, dont think that we need this
    //----------------------------------------------------------------------------------------------------------------------
    unsigned int m_sampling_strategy;
    //----------------------------------------------------------------------------------------------------------------------
    /// @brief Our environment map texture sample
    //----------------------------------------------------------------------------------------------------------------------
    optix::TextureSampler m_enviSampler;
    //----------------------------------------------------------------------------------------------------------------------
    /// @brief Translates the environment relative to the camera translations
    //----------------------------------------------------------------------------------------------------------------------
    bool m_translateEnviroment;
    //----------------------------------------------------------------------------------------------------------------------
    /// @brief a test model
    //----------------------------------------------------------------------------------------------------------------------
    Mesh *m_testMesh;
    //----------------------------------------------------------------------------------------------------------------------
};

#endif // PATHTRACERSCENE_H
